import fs from 'fs';
import path from 'path';
import EventEmitter from 'events';
import { atom } from 'jotai';

import { store, subscribe } from 'lib/store';
import { coreInfoQuery, coreConnectedAtom } from 'lib/coreInfo';
import { settingsAtom } from 'lib/settings';

export const coreOutputAtom = atom<string[]>([]);
export const coreOutputPausedAtom = atom<boolean>(false);

interface TailOptions {
  separator?: RegExp | string | null;
  fsWatchOptions?: fs.WatchOptions;
  follow?: boolean;
  logger?: {
    info: (msg: string) => void;
    error: (msg: string) => void;
  };
  useWatchFile?: boolean;
  flushAtEOF?: boolean;
  encoding?: BufferEncoding;
  fromBeginning?: boolean;
}

interface Block {
  start: number;
  end: number;
}

export function togglePaused(): void {
  store.set(coreOutputPausedAtom, (paused) => !paused);
}

// Generated by CoffeeScript 2.3.1
const boundMethodCheck = function (
  instance: unknown,
  Constructor: { new (...args: any[]): any }
) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

function getLogFileLocation(): string {
  const { coreDataDir } = store.get(settingsAtom);
  const coreInfo = store.get(coreInfoQuery.valueAtom);

  let logPath = coreDataDir;
  if (coreInfo?.testnet) {
    logPath = path.join(logPath, `testnet${coreInfo.testnet}`);
  }
  if (coreInfo?.litemode) {
    logPath = path.join(logPath, 'client');
  }
  logPath = path.join(logPath, 'log', '0.log');
  return logPath;
}

function printCoreOutput(output: string[]): void {
  store.set(coreOutputAtom, (currentOutput) => {
    let newOutput = [...output, ...currentOutput];
    if (newOutput.length > 1000) {
      newOutput = newOutput.slice(0, 1000);
    }
    return newOutput;
  });
}

class Tail extends EventEmitter {
  private filename: string;
  private separator: RegExp | string | null;
  private fsWatchOptions: fs.WatchOptions;
  private follow: boolean;
  private logger?: TailOptions['logger'];
  private useWatchFile: boolean;
  private flushAtEOF: boolean;
  private encoding: BufferEncoding;
  private buffer: string;
  private internalDispatcher: EventEmitter;
  private queue: Block[];
  private isWatching: boolean;
  private pos: number = 0;
  private watcher?: fs.FSWatcher;

  readBlock(): void {
    var block, stream;
    boundMethodCheck(this, Tail);
    if (this.queue.length >= 1) {
      block = this.queue[0];
      if (block.end > block.start) {
        stream = fs.createReadStream(this.filename, {
          start: block.start,
          end: block.end - 1,
          encoding: this.encoding,
        });
        stream.on('error', (error) => {
          if (this.logger) {
            this.logger.error(`Tail error: ${error}`);
          }
          return this.emit('error', error);
        });
        stream.on('end', () => {
          this.queue.shift();
          if (this.queue.length > 0) {
            this.internalDispatcher.emit('next');
          }
          if (this.flushAtEOF && this.buffer.length > 0) {
            this.emit('line', this.buffer);
            this.buffer = '';
            return;
          }
        });
        stream.on('data', (data) => {
          var chunk, i, len, parts, results;
          if (this.separator === null) {
            return this.emit('line', data);
          } else {
            this.buffer += data;
            parts = this.buffer.split(this.separator);
            this.buffer = parts.pop()!;
            results = [];
            for (i = 0, len = parts.length; i < len; i++) {
              chunk = parts[i];
              results.push(this.emit('line', chunk));
            }
            return results;
          }
        });
      }
    }
  }

  constructor(filename: string, options: TailOptions = {}) {
    var fromBeginning;
    super();
    this.readBlock = this.readBlock.bind(this);
    this.change = this.change.bind(this);
    this.filename = filename;
    ({
      separator: this.separator = /[\r]{0,1}\n/,
      fsWatchOptions: this.fsWatchOptions = {},
      follow: this.follow = true,
      logger: this.logger,
      useWatchFile: this.useWatchFile = false,
      flushAtEOF: this.flushAtEOF = false,
      encoding: this.encoding = 'utf-8',
      fromBeginning: fromBeginning = false,
    } = options);
    if (this.logger) {
      this.logger.info('Tail starting...');
      this.logger.info(`filename: ${this.filename}`);
      this.logger.info(`encoding: ${this.encoding}`);
    }
    this.buffer = '';
    this.internalDispatcher = new EventEmitter();
    this.queue = [];
    this.isWatching = false;
    this.internalDispatcher.on('next', () => {
      return this.readBlock();
    });
    this.watch(fromBeginning);
  }

  private change(filename: string): void {
    let stats: fs.Stats;
    boundMethodCheck(this, Tail);
    try {
      stats = fs.statSync(filename);
    } catch (error) {
      if (this.logger) {
        this.logger.error(`'change' event for ${filename}. ${error}`);
      }
      this.emit('error', `'change' event for ${filename}. ${error}`);
      return;
    }
    if (stats.size < this.pos) {
      //scenario where texts is not appended but it's actually a w+
      this.pos = stats.size;
    }
    if (stats.size > this.pos) {
      this.queue.push({
        start: this.pos,
        end: stats.size,
      });
      this.pos = stats.size;
      if (this.queue.length === 1) {
        this.internalDispatcher.emit('next');
      }
    }
  }

  watch(fromBeginning?: boolean): void {
    var err, stats;
    if (this.isWatching) {
      return;
    }
    if (this.logger) {
      this.logger.info(`filesystem.watch present? ${fs.watch !== void 0}`);
      this.logger.info(`useWatchFile: ${this.useWatchFile}`);
      this.logger.info(`fromBeginning: ${fromBeginning}`);
    }
    this.isWatching = true;
    try {
      stats = fs.statSync(this.filename);
    } catch (error) {
      err = error;
      if (this.logger) {
        this.logger.error(`watch for ${this.filename} failed: ${err}`);
      }
      this.emit('error', `watch for ${this.filename} failed: ${err}`);
      return;
    }
    this.pos = fromBeginning ? 0 : stats.size;
    if (this.pos === 0) {
      this.change(this.filename);
    }
    if (!this.useWatchFile && fs.watch) {
      if (this.logger) {
        this.logger.info('watch strategy: watch');
      }
      this.watcher = fs.watch(
        this.filename,
        this.fsWatchOptions,
        (e, filename) => {
          return this.watchEvent(e, filename);
        }
      );
    } else {
      if (this.logger) {
        this.logger.info('watch strategy: watchFile');
      }
      fs.watchFile(this.filename, this.fsWatchOptions, (curr, prev) => {
        return this.watchFileEvent(curr, prev);
      });
    }
  }

  rename(filename: string): void {
    //MacOS sometimes throws a rename event for no reason.
    //Different platforms might behave differently.
    //see https://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener
    //filename might not be present.
    //https://nodejs.org/api/fs.html#fs_filename_argument
    //Better solution would be check inode but it will require a timeout and
    // a sync file read.
    if (filename === void 0 || filename !== this.filename) {
      this.unwatch();
      if (this.follow) {
        setTimeout(() => {
          return this.watch();
        }, 1000);
      } else {
        if (this.logger) {
          this.logger.error(
            `'rename' event for ${this.filename}. File not available.`
          );
        }
        this.emit(
          'error',
          `'rename' event for ${this.filename}. File not available.`
        );
      }
    }
  }

  // @logger.info("rename event but same filename")
  watchEvent(e: string, evtFilename: string): void {
    if (e === 'change') {
      return this.change(this.filename);
    } else if (e === 'rename') {
      return this.rename(evtFilename);
    }
  }

  watchFileEvent(curr: fs.Stats, prev: fs.Stats): void {
    if (curr.size > prev.size) {
      this.pos = curr.size; // Update @pos so that a consumer can determine if entire file has been handled
      this.queue.push({
        start: prev.size,
        end: curr.size,
      });
      if (this.queue.length === 1) {
        this.internalDispatcher.emit('next');
      }
    }
  }

  unwatch(): void {
    if (this.watcher) {
      this.watcher.close();
    } else {
      fs.unwatchFile(this.filename);
    }
    this.isWatching = false;
    this.queue = [];
    if (this.logger) {
      return this.logger.info(`Unwatch ${this.filename}`);
    }
  }
}

function processDeamonOutput(debugfile: string): void {
  const tailOptions: TailOptions = {
    useWatchFile: true,
  };
  tail = new Tail(debugfile, tailOptions);
  let batch: string[] = [];
  tail.on('line', (d: string) => {
    batch.push(d);
  });
  printCoreOutputTimer = setInterval(() => {
    const paused = store.get(coreOutputPausedAtom);
    if (paused) {
      return;
    }
    if (batch.length == 0) {
      return;
    }
    printCoreOutput(batch.reverse());
    batch = [];
  }, 1000);
}

let tail: Tail | null = null;
let tryTailingTimer: NodeJS.Timeout;
let printCoreOutputTimer: NodeJS.Timeout;

export function stopCoreOuputWatch(): void {
  if (tail) {
    tail.unwatch();
    tail = null;
  }
  store.set(coreOutputAtom, []);
  clearInterval(printCoreOutputTimer);
  clearTimeout(tryTailingTimer);
}

subscribe(coreConnectedAtom, (coreConnected) => {
  if (coreConnected) {
    const { manualDaemon } = store.get(settingsAtom);
    if (manualDaemon) return;

    const logPath = getLogFileLocation();
    const tryTailing = () => {
      fs.stat(logPath, (err) => {
        if (!err) {
          processDeamonOutput(logPath);
        } else {
          tryTailingTimer = setTimeout(tryTailing, 5000);
        }
      });
    };
    tryTailing();
  } else {
    stopCoreOuputWatch();
  }
});
